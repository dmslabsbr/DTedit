% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dtedit.R
\name{dteditUI}
\alias{dteditUI}
\title{Create a DataTable with external update using reactive data.}
\usage{
dteditUI(id)
}
\arguments{
\item{id}{the namespace of the module}
}
\description{
dteditUI - user-interface function
}
\details{
Use in conjunction with \code{callModule} and \code{dtedit} to create
editable datatables. \code{dteditUI} is used in the 'user interface' component
of the shiny app.
}
\examples{
##### Minimal DTedit example using reactive dataframe #####
library(shiny)
library(dtedit2)

##### Create the Shiny server #####
server <- function(input, output, session) {
  
  fruit <- data.frame(Column1 = c("Apple", "Cherry", "Frozen"),
                      Column2 = c("Pie", "Tart", "Yoghurt"),
                      stringsAsFactors = FALSE)
  
  now <- Sys.time()
  mult <- 80000
  dates_seq <- data.frame(Column1 = c(now,
                                  (now + mult),
                                  (now + mult * 2),
                                  (now + mult * 3),
                                  (now + mult * 4)),
                        Column2 = c('Data 1', 'Data 2', 'Data 3', 'Data 4', 'Data 5'))
  
  dates_seq2 <- data.frame(Column1 = as.Date(now) + 1:6 * 100,
                           Column2 = c('Data 1', 'Data 2', 'Data 3',
                                       'Data 4', 'Data 5', 'Data 6'))
  
  
  data <- reactiveVal() # # 'data' will be a 'reactive' dataframe
  data(fruit)
  
  data2 <- reactiveVal()
  data2(fruit)
  
  data_DT_gui <- callModule(dtedit2, 'dataspace',
                            thedataf = data, 
                             edit.cols = c("Column1", "Column2")
  )
  data_DT_gui2 <- callModule(dtedit2, 'dataspace2',
                             thedataf = data2, 
                             edit.cols = c("Column1", "Column2")
  )
  data_DT_gui3 <- callModule(dtedit2, 'dataspace3',
                             thedataf = dates_seq2, 
                             edit.cols = c("Column1", "Column2"),
                             date.format = 'dd-mm-yyyy',
                             date.method = 'toLocaleDateString'
  )
  
  observe({
    data(isolate(as.data.frame(data_DT_gui$thedata(), stringsasfactors = FALSE)))
    print(isolate(data()))
    print(paste("Edit count:", data_DT_gui$edit.count())) 
    # only reacts to change in $edit.count()
  })
  
  observeEvent(input$data_scramble, {
    print("Scrambling...")
    temp <- data()
    if (nrow(temp)>0) {
      row <- sample(1:nrow(temp), 1)  # row
      col <- sample(1:2, 1)           # column
      temp[row, col] <- paste(sample(unlist(strsplit(temp[row, col], "")),
                                     nchar(temp[row, col])),
                              sep = '', collapse = '')
      data(temp) # adjusted dataframe 'automatically' read by DTedit
    }
  })
  
  observeEvent(input$data2_change, {
    print("Changing...")
    new.fruit <- data.frame(Column1 = c("Banana", "Raspberries", "Tangerine"),
                        Column2 = c("Ice Cream", "Yoghurt", "Candy"),
                        stringsAsFactors = FALSE)
    data2(new.fruit) # adjusted dataframe 'automatically' read by DTedit
    print("ok")
  })
  
}

##### Create the shiny UI ######
ui <- fluidPage(
  h3("DTedit using reactive dataframe"),
  wellPanel(p("Try the 'Scramble' button!")),
  h1('dataspace'),
  dteditUI("dataspace"),
  actionButton("data_scramble", "Scramble an entry"),
  h1('dataspace2'),
  dteditUI("dataspace2"),
  actionButton("data2_change", "Change data2"),
  h1('dataspace3'),
  dteditUI("dataspace3")
)

shinyApp(ui = ui, server = server)
}
\seealso{
Other Datatable Edit functions: \code{\link{dtedit2}}
}
\concept{Datatable Edit functions}
